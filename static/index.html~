<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>A Tour of Go</title>

<!-- jQuery -->
<script src="static/jquery.js"></script>

<!-- CodeMirror -->
<link rel="stylesheet" href="/static/codemirror/lib/codemirror.css">
<script src="/static/codemirror/lib/codemirror.js"></script>
<script src="/static/codemirror/lib/go.js"></script>

<!-- Tour -->
<link rel="stylesheet" href="static/tour.css">
<script src="static/mode.js"></script>
<script src="static/tour.js"></script>

</head>
<body>
	<div id="wrap">
		<div id="header">
			<div id="slidenum">1</div>
				<a href="#toc" id="tocbtn" title="Table of Contents"></a>
				<h1>Go Turu</h1>
			</div>

			<div id="slides" class="slides"><!-- begin slides -->

<div class="slide">
	<h2>Merhaba, 世界</h2>
	<p>
	<a target="_blank" href="http://golang.org/">Go programlama dili</a>
	Turuna Hoş Geldiniz.
	<p>
	Tur 3 bölümden oluşmakta. Her bölümün sonunda bir dizi
	alıştırma tamamlamanızı bekliyor.
	<p>
	Tur interaktif. Şimdi "Run" butonuna basın (ya da
	Shift-Enter tuşlayın) kod derlenip program çalıştırılacak.
	<span class="appengineMode">bir uzak sunucu.</span>
	<span class="localMode">sizin bilgisayarınız.</span>
	Sonuç kodun aşağısında gösterilecek.
	<p>
	Örnek programlar sizi Go'nun farklı yönleriyle tanıştıracak.
	Bu programlar sizin gelecekteki tecrübeleriniz için ilk adımları
	oluşturacak.
	<p>
	Programı düzenleyip yeniden çalıştırın.
	<p>
	İlerlemeye hazır olduğunuzda "Next" butonuna tıklayın ya da
	PageDown tuşlayın.
<pre class="source">package main

import "fmt"

func main() {
	fmt.Println("Merhaba, 世界")
}</pre>
</div>

<div class="slide nocode appengineMode">
	<h2>Go lokal</h2>
	<p>
	Turu diğer dillerle de deneyebilirsiniz:
	<ul>
	<li><a href="http://go-tour-br.appspot.com/">Brezilya Portekizcesi &mdash; Português do Brasil</a></li>
	<li><a href="http://go-tour-zh.appspot.com/">Çince &mdash; 普通话</a></li>
	<li><a href="http://go-tour-jp.appspot.com/">Japonca &mdash; 日本語</a></li>
	</ul>
	<p>
	(Eğer turu başka bir dile çevirmek istiyorsanız, kaynak koda
	buradan ulaşabilirsiniz <code>https://code.google.com/p/go-tour</code>,
	<code>static/index.html</code>'i çevirin, daha sonra App Engine ile
	 "deploy" edin yardım için <code>appengine/README</code>.)
	<p>
	Devam etmek için "Next" butonuna tıklayın ya da Page Down tuşlayın.
</div>

<div class="slide nocode appengineMode">
	<h2>Go çevrimdışı</h2>
	<p>
	Bu tur aynı zamanda internet bağlantısı olmadan da kullanabileceğiniz
	tek başına çalıştırılabilir bir program.
	<p>
	Bu tur daha hızlı, kod parçalarını sizin bilgisayarınızda yaratıp
	çalıştıracak. Aynı zamanda diğer versiyonda yer almayan bir kaç
	alıştırma da içeriyor.
	<p>
	Turu lokal olarak çalıştırmak için önce
	<a target="_blank" href="http://golang.org/doc/install/">Go yükleyin</a>,
	sonra
	<a target="_blank" href="http://golang.org/cmd/go/">kaynak kodu</a> temin edip
	<a target="_blank" href="http://code.google.com/p/go-tour/">gotour</a>'a gidin:
	<pre>go get code.google.com/p/go-tour/gotour</pre>
	<p>
	ve <code>gotour</code>'u çalıştırın.
	<p>
	Ya da, devam etmek için "Next" butonuna tıklayın veya Page Down tuşlayın.
	<p>
	<i>(Bu bilgilere dilediğiniz zaman ulaşmak için "index" butonunu
	kullanabilirsiniz.)</i>
</div>

<div class="toc">Giriş</div>

<div class="slide">
	<h2>Paketler</h2>
	<p>
	Her Go programı paketlerden oluşur.
	<p>
	Programlar <code>main</code> paketi ile birlikte başlar.
	<p>
	Bu program paketleri <code>"fmt"</code> ve <code>"math"</code>
	import yolları ile kullanılır.
	<p>
	Geleneksel olarak, paket isimleri import yolunun son
	elementi ile isimlendirilir.
<pre class="source">package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println("Happy", math.Pi, "Day")
}</pre>
</div>

<div class="slide">
	<h2>İçe Aktarımlar</h2>
	<p>
	 Bu kod grupları import ifadesini parantezlenmiş ifadenin 
	içine aktarırlar. Ayrıca çoklu import ifadeleri de kullanabilirsiniz,
	<pre>import "fmt"
import "math"</pre> gibi
	ancak karışıklığı önlemek için genellikle diğer form kullanılır.
<pre class="source">package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Printf("Şimdi %g problemin var.",
		math.Nextafter(2, 3))
}</pre>
</div>

<div class="slide">
	<h2>İçe Aktarılan isimler</h2>
	<p>
	Bir paketi içe aktardıktan sonra, isimleri aktarabilirsiniz.
	<p>
	Go'da, bir isim büyük harf ile başlıyorsa içe aktarılmıştır.
	<p>
	<code>Foo</code> içe aktarılmış bir isim, tıpkı <code>FOO</code> gibi.
	<code>foo</code> ismi içe aktarılmamış.
	<p>
	Kodu çalıştırın. Daha sonra <code>math.pi</code>'ye <code>math.Pi</code>
	ismini verip yeniden çalıştırın.
<pre class="source">package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println(math.pi)
}</pre>
</div>

<div class="slide">
	<h2>Fonksiyonlar</h2>
	<p>
	Bir fonksiyon 0 veya daha fazla argüman alabilir.
	<p>
	Bu örnekte, <code>add</code> fonksiyonu <code>int</code> türünde 2 parametre alıyor.
	<p>
	Aklınızda bulunsun tür adı değişken adından <i>sonra</i> geliyor.
	<p>
	(Türlerin neden buna ihtiyaç duydukları hakkında daha fazla bilgi için, <a target="_blank" href="http://golang.org/doc/articles/gos_declaration_syntax.html"> buraya</a> bakın makale Go'nun "syntax ifadesi"ndendir.)
<pre class="source">package main

import "fmt"

func add(x int, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}</pre>
</div>

<div class="slide">
	<h2>Fonksiyonlar</h2>
	<p>
	Ardışık gelen 2 ya da daha fazla parametre bir türü paylaşıyorsa,
	tür adını en sona yazarak paylaştırabilirsiniz.
	<p>
	Bu örnekte,
	<pre>x int, y int</pre>
	<p>
	kod parçasını şuna kısalttık
	<pre>x, y int</pre>
<pre class="source">package main

import "fmt"

func add(x, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}</pre>
</div>

<div class="slide">
	<h2>Fonksiyonlar</h2>
	<p>
	Bir fonksiyon herhangi bir sayıda sonuç döndürebilir.
	<p>
	Bu fonksiyon 2 dizgi döndürüyor.
<pre class="source">package main

import "fmt"

func swap(x, y string) (string, string) {
	return y, x
}

func main() {
	a, b := swap("merhaba", "dünya")
	fmt.Println(a, b)
}</pre>
</div>

<div class="slide">
	<h2>Fonksiyonlar</h2>
	<p>
	Fonksiyonlar parametreler alırlar. Go'da fonksiyonlar birden fazla
	sonuç parametresi alabilirler. Onlar da değişken gibi isimlendirilebilir
	ve öyle davranabilirler.
	<p>
	Eğer sonuç parametreleri isimlendirilmişse, argümansız bir <code>return</code>
	 ifadesi sonuçların geçerli değerini döndürecektir.
<pre class="source">package main

import "fmt"

func split(sum int) (x, y int) {
	x = sum * 4/9
	y = sum - x
	return
}

func main() {
	fmt.Println(split(17))
}</pre>
</div>

<div class="slide">
	<h2>Değişkenler</h2>
	<p>
	<code>var</code> ifadesi değişkenleri listeler;
	tıpkı fonksiyon argümanları gibi, tür en sonda.

<pre class="source">package main

import "fmt"

var x, y, z int
var c, python, java bool

func main() {
	fmt.Println(x, y, z, c, python, java)
}</pre>
</div>

<div class="slide">
	<h2>Değişkenler</h2>
	<p>
	Bir var ifadesi tanımlayıcı içerebilir, her değişkene bir tane.
	<p>
	Eğer bir tanımlayıcı mevcut ise, tür atlanabilir;
	değişken tanımlayıcısının türünü alacaktır.
<pre class="source">package main

import "fmt"

var x, y, z int = 1, 2, 3
var c, python, java = true, false, "Hayır!"

func main() {
	fmt.Println(x, y, z, c, python, java)
}</pre>
</div>

<div class="slide">
	<h2>Değişkenler</h2>
	<p>
	Bir fonksiyondaki, <code>:=</code> kısa atama ifadesi
	 <code>var</code> ifadesinin yerine kullanılabilir .
	<p>
	(Fonksiyonun dışında, her yapı bir anahtar kelime ile başlar ve
	<code>:=</code> yapısı mümkün değildir.)
<pre class="source">package main

import "fmt"

func main() {
	var x, y, z int = 1, 2, 3
	c, python, java := true, false, "hayır!"

	fmt.Println(x, y, z, c, python, java)
}</pre>
</div>

<div class="slide">
	<h2>Sabitler</h2>
	<p>
	Sabitler de değişkenler gibidir ama <code>const</code> anahtar kelimesi
	ile kullanılırlar.
	<p>
	Sabitler, karakter, dizgi, boolean, ya da sayısal değerler alabilirler.
<pre class="source">package main

import "fmt"

const Pi = 3.14

func main() {
	const World = "Dünya"
	fmt.Println("Merhaba", World)
	fmt.Println("Mutlu", Pi, "Gün")

	const Truth = true
	fmt.Println("Go muhteşem mi?", Truth)
}</pre>
</div>

<div class="slide">
	<h2>Sayısal Sabitler</h2>
	<p>
	Sayısal sabitler yüksek hassasiyetli <i>değerlerdir</i>.
	<p>
	Türü olmayan bir sabit kaynağının ihtiyaç duyduğu türü alır.
	<p>
	<code>needInt(Big)</code> kodunu da eklemeyi deneyin.
<pre class="source">package main

import "fmt"

const (
	Big = 1&lt;&lt;100
	Small = Big&gt;&gt;99
)

func needInt(x int) int { return x*10 + 1 }
func needFloat(x float64) float64 {
	return x*0.1
}

func main() {
	fmt.Println(needInt(Small))
	fmt.Println(needFloat(Small))
	fmt.Println(needFloat(Big))
}</pre>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	Go sadece bir döngü yapısına sahip, <code>for</code> döngüsü.
	<p>
	<code>for</code> döngüsü C ya da Java'dakiyle aynı gibi,
	yalnızca <code>( )</code> kısmı gitti (opsiyonal bile değiller)
	ve <code>{ }</code> kısmı gerekli. 
<pre class="source">package main

import "fmt"

func main() {
	sum := 0
	for i := 0; i &lt; 10; i++ {
		sum += i
	}
	fmt.Println(sum)
}</pre>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	Tıpkı C ve Java'daki gibi, ilk ve son ifadeleri boş bırakabilirsiniz.
<pre class="source">package main

import "fmt"

func main() {
	sum := 1
	for ; sum &lt; 1000; {
		sum += sum
	}
	fmt.Println(sum)
}</pre>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	Bu noktada, noktalı virgülleri bırakabilirsiniz:
	C'nin <code>while</code>'ı Go'da <code>for</code> diye okunur.
<pre class="source">package main

import "fmt"

func main() {
	sum := 1
	for sum &lt; 1000 {
		sum += sum
	}
	fmt.Println(sum)
}</pre>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	Eğer döngü koşulunu atlarsanız, sonsuz döngüye girer.
<pre class="source">package main

func main() {
	for ; ; {
	}
}</pre>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	Ve tüm cümlecikleri çıkararak, noktalı virgülleri atlayabilir,
	yani sonsuz döngüyü kısaltabiliriz.
<pre class="source">package main

func main() {
	for {
	}
}</pre>
</div>

<div class="slide">
	<h2>If</h2>
	<p>
	<code>if</code> döngüsü C ya da Java'dakiyle aynı gibi,
	yalnızca <code>( )</code> kısmı gitti (opsiyonal bile değiller)
	ve <code>{ }</code> kısmı gerekli.
	<p>
	(Tanıdık geldi değil mi?)
<pre class="source">package main

import (
	"fmt"
	"math"
)

func sqrt(x float64) string {
	if x &lt; 0 {
		return sqrt(-x) + "i"
	}
	return fmt.Sprint(math.Sqrt(x))
}

func main() {
	fmt.Println(sqrt(2), sqrt(-4))
}</pre>
</div>

<div class="slide">
	<h2>If</h2>
	<p>
	<code>for</code>'daki gibi, <code>if</code> ifadesi de koşuldan önce çalıştırılabilmesi
	 için  kısa atama ile başlayabilir.
	<p>
	Değişkenlerin geçerliliği <code>if</code> ifadesinin kapsamı içindedir.
	<p>
	(Sondaki <code>return</code> ifadesinde <code>v</code> kullanmayı deneyin.)
<pre class="source">package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v &lt; lim {
		return v
	}
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}</pre>
</div>

<div class="slide">
	<h2>If</h2>
	<p>
	<code>if</code>'in içerisinde kısa atama ile atanan değişkenlerin
	kullanımı <code>else</code> bloklarında da mümkündür.
<pre class="source">package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v &lt; lim {
		return v
	} else {
		fmt.Printf("%g >= %g\n", v, lim)
	}
	// burada v'yi kullanamayız, eğer şu yoksa
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}</pre>
</div>

<div class="slide">
	<h2>Temel türler</h2>
	<p>
	Go'nun temel türleri
	<pre>bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // diğer adıyla uint8

rune // diğer adıyla int32
     // bir Unicode kodu temsil eder

float32 float64

complex64 complex128</pre>
<pre class="source">package main

import (
	"math/cmplx"
	"fmt"
)

var (
	ToBe bool = false
	MaxInt uint64 = 1&lt;&lt;64 - 1
	z complex128 = cmplx.Sqrt(-5+12i)
)

func main() {
	const f = "%T(%v)\n"
	fmt.Printf(f, ToBe, ToBe)
	fmt.Printf(f, MaxInt, MaxInt)
	fmt.Printf(f, z, z)
}</pre>
</div>

<div class="slide">
	<h2>Yapılar</h2>
	<p>
	Bir <code>struct</code> (yapı) alanların toplamasıdır.
	<p>
	(Ve bir <code>type</code> ifadesi bekleneni gerçekleştirir.)
<pre class="source">package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	fmt.Println(Vertex{1, 2})
}</pre>
</div>

<div class="slide">
	<h2>Yapı Alanları</h2>
	<p>
	Yapı alanları nokta kullanılarak çağrılır.
<pre class="source">package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	v := Vertex{1, 2}
	v.X = 4
	fmt.Println(v.X)
}</pre>
</div>

<div class="slide">
	<h2>İşaretçiler</h2>
	<p>
	Go'nun işaretçileri var ama işaretçi aritmetiği yok.
	<p>
	Yapı alanlarına bir yapı işaretçisi ile de erişilebilir.
	İşaretçi ile sağlanan bu dolaylı yol şeffaftır.
<pre class="source">package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	p := Vertex{1, 2}
	q := &amp;p
	q.X = 1e9
	fmt.Println(p)
}</pre>
</div>

<div class="slide">
	<h2>Yapısal Sabitler</h2>
	<p>
	Yapısal sabitler henüz tahsis edilmiş yapı değerini alanına göre listeleyerek belirtir.
	<p>
	<code>Name:</code> syntax'ını kullanarak yalnızca alt alanları listeleyebilirsiniz
	(Sırasıyla isimlendirilmiş alanlar konu dışındadır.)
	<p>
	Özel <code>&amp;</code> gösterimi yapısal bir sabite işaretçi tahsis eder.
<pre class="source">package main

import "fmt"

type Vertex struct {
	X, Y int
}

var (
	p = Vertex{1, 2}  // Vertex türüne sahip
	q = &amp;Vertex{1, 2} // *Vertex türüne sahip
	r = Vertex{X: 1}  // örtülü biçimde Y:0 
	s = Vertex{}      // X:0 ve Y:0
)

func main() {
	fmt.Println(p, q, r, s)
}</pre>
</div>

<div class="slide">
	<h2>Yeni bir fonksiyon</h2>
	<p>
	<code>new(T)</code> ifadesi, sıfırlanmış bir <code>T</code>
	değeri tahsis eder ve ona bir işaretçi döndürür.
	<pre>var t *T = new(T)</pre>
	<p>
	or
	<pre>t := new(T)</pre>
<pre class="source">package main

import "fmt"

type Vertex struct {
	X, Y int
}

func main() {
	v := new(Vertex)
	fmt.Println(v)
	v.X, v.Y = 11, 9
	fmt.Println(v)
}</pre>
</div>

<div class="slide">
	<h2>Eşlemler</h2>
	<p>
	Bir eşlem("map") anahtarları değerlere eşler.
	<p>
	<!-- TODO: empty part not true in compilers yet -->
	Eşlemler mutlaka <code>make</code> ile yaratılmalıdır (<code>new</code> ile değil)
	kullanmadan önce;<code>nil</code> eşlemi boştur ve atanabilir değildir.
<pre class="source">package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m map[string]Vertex

func main() {
	m = make(map[string]Vertex)
	m["Bell Labs"] = Vertex{
		40.68433, 74.39967,
	}
	fmt.Println(m["Bell Labs"])
}</pre>
</div>

<div class="slide">
	<h2>Eşlemler</h2>
	<p>
	Eşlem değişmezleri de yapı değişmezleri gibidir ama anahtarlar gereklidir.
<pre class="source">package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m = map[string]Vertex{
	"Bell Labs": Vertex{
		40.68433, -74.39967,
	},
	"Google": Vertex{
		37.42202, -122.08408,
	},
}

func main() {
	fmt.Println(m)
}</pre>
</div>

<div class="slide">
	<h2>Eşlemler</h2>
	<p>
	Eğer üst-seviye tür yalnızca tür adı ise, onu değişmezin elemanları
	arasında görmezden gelebilirsiniz.
<pre class="source">package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m = map[string]Vertex{
	"Bell Labs": {40.68433, -74.39967},
	"Google":    {37.42202, -122.08408},
}

func main() {
	fmt.Println(m)
}</pre>
</div>

<div class="slide">
	<h2>Eşlemleri Değiştirme</h2>
	<p>
	Eşlemimize("map") bir eleman ekleyelim ya da güncelleyelim <code>m</code>:
	<pre>m[key] = elem</pre>
	<p>
	Bir elemanı çekelim:
	<pre>elem = m[key]</pre>
	<p>
	Bir elemanı silelim:
	<pre>delete(m, key)</pre>
	<p>
	Çift değer atamasındaki anahtarı test edelim:
	<pre>elem, ok = m[key]</pre>
	<p>
	Eğer <code>key</code>, <code>m</code> içindeyse,
	<code>ok</code> <code>true</code> olacaktır.
	Eğer değilse, <code>ok</code>  <code>false</code> ve
	<code>elem</code> eşlemin eleman türü için sıfır değerini alacaktır.
	<p>
	Benzer şekilde, bir eşlemden okurken eğer anahtar mevcut değilse
	sonuç eşlemin eleman türü için sıfır değerini alır.
<pre class="source">package main

import "fmt"

func main() {
	m := make(map[string]int)

	m["Cevap"] = 42
	fmt.Println("The value:", m["Cevap"])

	m["Cevap"] = 48
	fmt.Println("The value:", m["Cevap"])

	delete(m, "Cevap")
	fmt.Println("The value:", m["Cevap"])

	v, ok := m["Cevap"]
	fmt.Println("Değer:", v, "Mevcut mu?", ok)
}</pre>
</div>

<div class="slide">
	<h2>Dilimler</h2>
	<p>
	Değerlerden oluşan bir diziyi ya da uzunluğu belirtir.
	<p>
	<code>[]T</code>, <code>T</code> türünden elemanları olan bir dilimdir.
<pre class="source">package main

import "fmt"

func main() {
	p := []int{2, 3, 5, 7, 11, 13}
	fmt.Println("p ==", p)

	for i := 0; i &lt; len(p); i++ {
		fmt.Printf("p[%d] == %d\n",
			i, p[i])
	}
}</pre>
</div>

<div class="slide">
	<h2>Dilimler</h2>
	<p>
	!Dilimler yeniden kesilebilir, aynı diziyi işaret eden yeni bir
	dilim yaratalım.
	<p>
	<pre>s[lo:hi]</pre>
	<p>
	İfadesi "<code>lo</code>"dan "<code>hi-1</code>"i de kapsayan elemanları 
	değerlendirir. Böylece
	<pre>s[lo:lo]</pre>
	<p>
	boştur ve
	<pre>s[lo:lo+1]</pre>
	<p>
	bir elemana sahiptir.
<pre class="source">package main

import "fmt"

func main() {
	p := []int{2, 3, 5, 7, 11, 13}
	fmt.Println("p ==", p)
	fmt.Println("p[1:4] ==", p[1:4])

	// !!!missing low index implies 0
	fmt.Println("p[:3] ==", p[:3])

	// missing high index implies len(s)
	fmt.Println("p[4:] ==", p[4:])
}</pre>
</div>

<div class="slide">
	<h2>Dilimler</h2>
	<p>
	Dilimler <code>make</code> fonkisiyonu ile yaratılır. Sıfırlanmış bir dizi
	tahsis ederek ve bu diziye kaynak olacak bir dilim döndürerek çalışır:
	<pre>a := make([]int, 5)  // len(a)=5</pre>
	Dilimlerin uzunlukları ve kapasiteleri vardır. Bir dilimin kapasitesi ulaşabildiği
	maksimum uzunluktur dilim temel aldığı dizi içinde büyüyebilir.
	<p>
	Kapasiteyi daha açık belirtmek için, <code>make</code>'e bir üçüncü argüman atayalım:
	<p>
	<pre>b := make([]int, 0, 5) // len(b)=0, cap(b)=5</pre>
	Dilimler "yeniden-dilimlendirilerek" büyüyebilirler (kapasitelerini artırmak adına):
	<p>
	<pre>b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4</pre>
<pre class="source">package main

import "fmt"

func main() {
	a := make([]int, 5)
	printSlice("a", a)
	b := make([]int, 0, 5)
	printSlice("b", b)
	c := b[:2]
	printSlice("c", c)
	d := c[2:5]
	printSlice("d", d)
}

func printSlice(s string, x []int) {
	fmt.Printf("%s len=%d cap=%d %v\n",
		s, len(x), cap(x), x)
}</pre>
</div>

<div class="slide">
	<h2>Dilimler</h2>
	<p>
	Bir dilimin "sıfır" değeri <code>nil</code>'dir.
	<p>
	Bu dilimin uzunluğu ve kapasite değeri 0'dır.
	<p>
	(Dilimler hakkında daha fazla bilgi için:
	"<a target="_blank" href="http://golang.org/doc/articles/slices_usage_and_internals.html">Dilimler: kullanımı ve iç bilgisi</a>"
	makalesini okuyun.)
<pre class="source">package main

import "fmt"

func main() {
	var z []int
	fmt.Println(z, len(z), cap(z))
	if z == nil {
		fmt.Println("nil!")
	}
}</pre>
</div>

<div class="slide">
	<h2>Fonksiyonlar</h2>
	<p>
	Fonksiyonlar da birer değerdir.
<pre class="source">package main

import (
	"fmt"
	"math"
)

func main() {
	hypot := func(x, y float64) float64 {
		return math.Sqrt(x*x + y*y)
	}

	fmt.Println(hypot(3, 4))
}</pre>
</div>

<div class="slide">
	<h2>Fonksiyonlar</h2>
	<p>
	Fonksiyonlar kaplamlarla ("closure") doludur.
	<p>
	<code>adder</code> fonksiyonu bir kaplam döndürür.
	Her kaplam kendi <code>sum</code> değişkenini saklar.
<pre class="source">package main

import "fmt"

func adder() func(int) int {
	sum := 0
	return func(x int) int {
		sum += x
		return sum
	}
}

func main() {
	pos, neg := adder(), adder()
	for i := 0; i &lt; 10; i++ {
		fmt.Println(
			pos(i),
			neg(-2*i),
		)
	}
}</pre>
</div>

<div class="slide">
	<h2>Erim</h2>
	<p>
	<code>for</code> döngüsünün <code>range</code> formu
	bir dilim veya eşlem üzerinde dolaşır.
<pre class="source">package main

import "fmt"

var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
	for i, v := range pow {
	    fmt.Printf("2**%d = %d\n", i, v)
	}
}</pre>
</div>

<div class="slide">
	<h2>Erim</h2>
	<p>
	İndisi ya da değeri <code>_</code> ataması ile geçebilirsiniz.
	<p>
	Eğer yalnızca indisi istiyorsanız, &ldquo;<code>, değeri</code>&rdquo;
	tamamen çıkarın.
<pre class="source">package main

import "fmt"

func main() {
	pow := make([]int, 10)
	for i := range pow {
		pow[i] = 1&lt;&lt;uint(i)
	}
	for _, value := range pow {
		fmt.Printf("%d\n", value)
	}
}</pre>
</div>

<div class="slide">
	<h2>Anahtarlama</h2>
	<p>
	Muhtemelen "<code>switch</code>"in neye benzediği hakkında biraz bilginiz vardır.
	<p>
	Örneğin gövde kendiliğinden bozulduysa; "<code>fallthrough</code> durumu" ile bitmemesi kaydıyla.

<pre class="source">package main

import (
	"fmt"
	"runtime"
)

func main() {
	fmt.Print("Go runs on ")
	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	case "linux":
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.", os)
	}
}</pre>
</div>

<div class="slide">
	<h2>Anahtarlama</h2>
	<p>
	"Switch",  "case"lerini baştan aşağı değerlendirir, "case"lerden biri
	doğrulanırsa durur.
	<p>
	(Örneğin,
	<pre>switch i {
case 0:
case f():
}</pre>
	<p>
	eğer <code>i==0</code> ise <code>f</code>'yi çağırmaz.)

<pre class="source">package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("Cumartesi ne zaman?")
	today := time.Now().Weekday()
	switch time.Saturday {
	case today+0:
		fmt.Println("Bugün.")
	case today+1:
		fmt.Println("Yarın.")
	case today+2:
		fmt.Println("2 gün sonra.")
	default:
		fmt.Println("Çok uzaklarda.")
	}
}</pre>
</div>

<div class="slide">
	<h2>Anahtarlama</h2>
	<p>
	Koşulsuz "switch" ifadeleri ile "<code>switch true</code>" aynı şeydir.
	<p>
	Bu kavram uzun "if-then-else" zincirleri yerine kullanılabilecek temiz bir yoldur.
<pre class="source">package main

import (
	"fmt"
	"time"
)

func main() {
	t := time.Now()
	switch {
	case t.Hour() &lt; 12:
	    fmt.Println("Günaydın!")
	case t.Hour() &lt; 17:
	    fmt.Println("İyi günler.")
	default:
	    fmt.Println("İyi akşamlar.")
	}
}</pre>
</div>

<div class="slide">
	<h2>Uygulama: Döngüler ve Fonksiyonlar</h2>
	<p>
	Fonksiyonlar ve döngülerle uğraşmanın basit bir yolu olarak, Newton'un
	metodunu kullanarak karekök fonksiyonunu yazabiliriz.
	<p>Burada, Newton'un metodu kendisine bir <i>z</i> başlangıç 
	noktası seçecek ve
	<div style="text-align: center">
	<img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=z=z-\frac{z^2-x}{2z}" alt="Newton's method">
	</div> formülünü döndürerek <code>Sqrt(x)</code>'e yaklaşacak
	<p>
	Başlangıç olarak, bu hesaplamayı 10 defa tekrar edin ve (1, 2, 3, ...) gibi çeşitli değerlerde
	cevaba ne kadar yaklaştığınızı görün.
	<p>
	Daha sonra, döngü koşulunu, değer değişmeyi bıraktığında (ya da çok küçük bir delta ile değiştiğinde) 
	duracak şekilde biçimlendirin .
	Daha fazla ya da daha az yineleme için buraya göz atın.
	<a target="_blank" href="http://golang.org/pkg/math/#Sqrt">math.Sqrt</a>'ye ne kadar yakınsınız?
	<p>
	İpucu: bir kayan nokta değerini (floating point value)ifade etmek ve tanımlamak için
	kayan nokta syntax'ını verin ya da bir dönüştürme uygulayın:
	<pre>z := float64(1)
z := 1.0</pre>

<pre class="source">package main

import (
	"fmt"
)

func Sqrt(x float64) float64 {
}

func main() {
	fmt.Println(Sqrt(2))
}</pre>
</div>

<div class="slide">
	<h2>Uygulama: Eşlemler</h2>
	<p>
	"<code>WordCount</code>"u uygulayalım. <code>s</code> dizgisinin içerisindeki
	her &ldquo;kelime&rdquo; için bir eşlem döndürmeli. 
	<code>wc.Test</code> fonksiyonu, bu fonksiyona karşı bir test sürüşü
	gerçekleştirecek ve başarıyı ya da başarısızlığı çıktı olarak verecek.
	<p>
	"<a target="_blank" href="http://golang.org/pkg/strings/#Fields">strings.Fields</a>"a bakmanızda fayda var.

<pre class="source">package main

import (
	"<span class="appengineMode">tour</span><span class="localMode">code.google.com/p/go-tour</span>/wc"
)

func WordCount(s string) map[string]int {
	return map[string]int{"x": 1}
}

func main() {
	wc.Test(WordCount)
}</pre>
</div>

<div class="slide">
	<h2>Uygulama: Dilimler</h2>
	<p>
	"<code>Pic</code>"i uygulayalım.<code>dx</code>'in dilimi olan her eleman için,
	<code>dy</code> uzunluğunda bir dilim döndürmeli.
	8-bit işaretsiz tamsayı. Programı çalıştırdığınızda, sizin fotoğrafınızı
	gösterecek, tamsayıları griölçekli (ee, maviölçekli) değerler olarak çıkaracak.
	<p>
	Resim seçimi size kalmış.
	İlginç fonksiyonlar içerebilir <code>x^y</code>, <code>(x+y)/2</code> ve <code>x*y</code>.
	<p>
	(<code>[][]uint8</code> içerisindeki her "<code>[]uint8</code>"i ayırmak için
	döngü kullanmanız gerekebilir.)
	<p>
	(Türler arasında dönüşüm uygulamak için <code>uint8(intValue)</code> kullanın.)

<pre class="source">package main

import "<span class="appengineMode">tour</span><span class="localMode">code.google.com/p/go-tour</span>/pic"

func Pic(dx, dy int) [][]uint8 {
}

func main() {
	pic.Show(Pic)
}</pre>
</div>

<div class="slide">
	<h2>Uygulama: Fibonacci closure</h2>
	<p>
	Hadi fonksiyonlarla biraz oynayalım.
	<p>
	<code>Fibonacci</code> uygulaması ardışık fibonacci sayıları döndüren
	bir fonksiyonu, kaplamı döndürür .

<pre class="source">package main

import "fmt"

// fibonacci, tamsayı değerleri döndüren
// bir fonksiyonu döndüren bir fonksiyondur.
func fibonacci() func() int {
}

func main() {
	f := fibonacci()
	for i := 0; i &lt; 10; i++ {
		fmt.Println(f())
	}
}</pre>
</div>

<div class="slide">
	<h2>Gelişmiş Uygulama: Karmaşık küp kökler</h2>
	<p>
	Hadi Go'nun kompleks sayılar için, içinde bulundurduğu <code>complex64</code> 
	ve <code>complex128</code> türlerini inceleyelim .
	Küp kökler için, Newton'un metodu:
	<div style="text-align: center">
	<img src="https://chart.googleapis.com/chart?cht=tx&amp;chl=z=z-\frac{z^3-x}{3z^2}" alt="Newton's method">
	</div>
	formülünü tekrarlayarak sonuca gider.
	<p>
	Yalnızca algoritmanın çalıştığından emin olmak için, 2'nin küp kökünü bulun.
	<code>math/cmplx</code> paketinin içinde bir <a target="_blank" href="http://golang.org/pkg/math/cmplx/#Pow">Pow</a>
	fonksiyonu var.

<pre class="source">package main

import "fmt"

func Cbrt(x complex128) complex128 {
}

func main() {
	fmt.Println(Cbrt(2))
}</pre>
</div>


<div class="toc">Metodlar ve Arayüzler</div>

<div class="slide nocode">
<h2>Metodlar ve Arayüzler</h2>
</div>

<div class="slide">
	<h2>Metodlar</h2>
	<p>
	Go'nun sınıfları yok. Buna rağmen, "struct" türlerinde metod tanımlayabilirsiniz.
	<p>
	<i>Metod alıcısı</i>, <code>func</code> anahtar sözcüğü ve metod ismi arasında
	kendi argüman listesinde belirir.
<pre class="source">package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := &amp;Vertex{3, 4}
	fmt.Println(v.Abs())
}</pre>
</div>

<div class="slide">
	<h2>Metodlar</h2>
	<p>
	Hatta, metodunuzu paketinizde tanımladığını <i>herhangi</i> bir türde
	tanımlayabilirsiniz, sadece "struct"larda değil.
	<p>
	Başka bir paketten alacağınız bir türde metod tanımlayamazsınız,
	ya da temel bir türde.
<pre class="source">package main

import (
	"fmt"
	"math"
)

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f &lt; 0 {
		return float64(-f)
	}
	return float64(f)
}

func main() {
	f := MyFloat(-math.Sqrt2)
	fmt.Println(f.Abs())
}</pre>
</div>

<div class="slide">
	<h2>İşaretçi alıcılarıyla metodlar</h2>
	<p>
	Metodlar isimlendirilmiş türlerle ya da işaretçilerle yönlendirilmiş,
	isimlendirilmiş türlerle ilişkilendirilebilir.
	<p>
	Henüz şimdi iki tane <code>Abs</code> metodu gördük. Birisi
	<code>*Vertex</code>'de işaretçi türünde ve diğeri
	<code>MyFloat</code>'da değer türünde.
	<p>
	İşaretçi alıcısı kullanmanın iki nedeni var.
	Birincisi, metod her çağrıldığında değeri kopyalamasını önlemek için 
	(eğer türü "large struct" ise daha verimli). İkincisi, bu sayede metod
	işaretçiler sayesinde değeri güncelleyebilir.
	<p>
	<code>*Vertex</code> yerine <code>Vertex</code>'i alıcı olarak kullanmak için
	<code>Abs</code> ve <code>Scale</code> metod ifadelerini değiştirmeyi deneyin.
	<p>
	<code>v</code> bir <code>Vertex</code> olduğunda, <code>Scale</code>
	metodunun bir etkisi kalmaz. <code>Scale</code>, <code>v</code>'yi değişime uğratır.
	<code>v</code> bir değer olduğunda (işaretçi-değil), metod onu <code>Vertex</code>'in
	bir kopyası olarak görecek ve asıl değeri değiştirmeyecektir.
	<p>
	<code>Abs</code> diğer türlü de çalışır. Yalnızca <code>v</code>'yi okur.
	Asıl ifadeyi okumasıyla kopyalanmış ifadeyi okuması (işaretçi vasıtasıyla)
	arasında bir fark yoktur.
<pre class="source">package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := &amp;Vertex{3, 4}
	v.Scale(5)
	fmt.Println(v, v.Abs())
}</pre>
</div>

<div class="slide">
	<h2>Arayüzler</h2>
	<p>
	Bir arayüz("interface") türü bir dizi metod tarafından belirlenir.
	<p>
	Arayüz türünün herhangi bir değeri metodarı gerçekleyen
	değerlerden birini tutabilir.

<pre class="source">package main

import (
	"fmt"
	"math"
)

type Abser interface {
	Abs() float64
}

func main() {
	var a Abser
	f := MyFloat(-math.Sqrt2)
	v := Vertex{3, 4}

	a = f  // MyFloat, Abser'i oluşturur
	a = &amp;v // *Vertex, Abser'i oluşturur
	a = v  // Vertex, Abser'i
	       // OLUŞTURMAZ

	fmt.Println(a.Abs())
}

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f &lt; 0 {
		return float64(-f)
	}
	return float64(f)
}

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}</pre>
</div>

<div class="slide">
	<h2>Arayüzler</h2>
	<p>
	Bir tür metodları tamamlayarak, arayüzleri de tamamlar.
	<p>
	<i>Niyetin aşikar bir açıklaması yoktur.</i>
	<p>
	Örtük arayüzler, uygulama paketlerini arayüzlerin tanımlandığı 
	paketlerden ayırırlar: birbirlerine bağlı da değillerdir.
	<p>
	Aynı zamanda açık arayüzlerin tanımlanması için teşvik eder, çünkü
	her uygulamayı tek tek bulup yeni bir arayüz ismiyle etiketlemek zorunda değilsiniz.
	<p>
	<a target="_blank" href="http://golang.org/pkg/io/">Package io</a>, "<code>Reader</code>" ve "<code>Writer</code>"ı tanımlar
	sizin yapmanıza gerek yok.
<pre class="source">package main

import (
	"fmt"
	"os"
)

type Reader interface {
	Read(b []byte) (n int, err error)
}

type Writer interface {
	Write(b []byte) (n int, err error)
}

type ReadWriter interface {
	Reader
	Writer
}

func main() {
	var w Writer

	// os.Stdout, Writer'a uygular
	w = os.Stdout

	fmt.Fprintf(w, "merhaba, writer\n")
}</pre>
</div>

<div class="slide">
	<h2>Hatalar</h2>
	<p>
	Kendini hata dizgisi olarak tarif edebilen her şey bir "hata"dır.
	Bu fikir önceden tasarlanmış, yapısal arayüz türünde, <code>error</code>'da,
	kendi tekil metoduyla, <code>Error</code>, saklanır, bir dizgi döndürür:
	<pre>type error interface {
	Error() string
}</pre>

	<p>
	"<code>fmt</code>" paketlerinin kendi çıktı türleri bir "<code>error</code>"
	çıktısı istendiğinde onu nasıl sunacaklarını otomatik olarak bilirler.

<pre class="source">package main

import (
	"fmt"
	"time"
)

type MyError struct {
	When time.Time
	What string
}

func (e *MyError) Error() string {
	return fmt.Sprintf("at %v, %s",
		e.When, e.What)
}

func run() error {
	return &amp;MyError{
		time.Now(),
		"çalışmadı",
	}
}

func main() {
	if err := run(); err != nil {
		fmt.Println(err)
	}
}</pre>
</div>

<div class="slide">
	<h2>Web sunucuları</h2>
	<p>
	<a target="_blank" href="http://golang.org/pkg/net/http/">http paketi</a> uygulanabilir değerleri kullanarak
	HTTP isteklerini sunar <code>http.Handler</code>:
	<pre>package http

type Handler interface {
	ServeHTTP(w ResponseWriter, r *Request)
}</pre>
	<p>
	Bu örnekte, <code>Hello</code> türü "<code>http.Handler</code>"ı gerçekliyor.
	<p>
	<span class="localMode">
	Selamlamayı görmek için <a href="http://localhost:4000/" target="_blank">http://localhost:4000/</a>'i ziyaret edin.
	</span>
	<span class="appengineMode">
	<b>Not:</b> Bu örnek web-tabanlı kullanıcı arayüzünde çalışmayacaktır.
	Web sunucuları yazmayı denemek için <a target="_blank" href="http://golang.org/doc/install/"> Go yüklemek
	isteyebilirsiniz</a>.
	</span>
<pre class="source">package main

import (
	"fmt"
	"net/http"
)

type Hello struct{}

func (h Hello) ServeHTTP(
		w http.ResponseWriter,
		r *http.Request) {
	fmt.Fprint(w, "Merhaba!")
}

func main() {
	var h Hello
	http.ListenAndServe("localhost:4000",h)
}</pre>
</div>

<div class="slide">
	<h2>Görüntüler</h2>
	<p>
	<a target="_blank" href="http://golang.org/pkg/image/#Image">"Image" paketi</a>, <code>Görüntü</code> arayüzünü
	tanımlar:
	<pre>package image

type Image interface {
	ColorModel() color.Model
	Bounds() Rectangle
	At(x, y int) color.Color
}</pre>
	<p>
	(Detaylar için <a target="_blank" href="http://golang.org/pkg/image/#Image"> bu dokümana</a> göz atın.
	<p>
	
	Ayrıca, <code>color.Color</code> ve <code>color.Model</code> birer arayüzdür ama 
	<code>color.RGBA</code> ve <code>color.RGBAModel</code> öntanımlı uygulamaları için
	bunu görmezden geleceğiz.

<pre class="source">package main

import (
	"fmt"
	"image"
)

func main() {
	m := image.NewRGBA(image.Rect(0, 0, 100, 100))
	fmt.Println(m.Bounds())
	fmt.Println(m.At(0, 0).RGBA())
}</pre>
</div>

<div class="slide">
	<h2>Uygulama: Hatalar</h2>
	<p>
	<code>Sqrt</code> fonksiyonunuzu önceki egzersizlerden kopyalayın ve onu bir
	<code>error</code> değerine çevirin.
	<p>
	<code>Sqrt</code> negatif bir sayı verildiğinde nil olamayan bir
	hata mesajı döndürmelidir, tıpkı kompleks sayıları desteklemediğinde yapacağı gibi.
	<p>
	Yeni bir tür oluşturun
	<pre>type ErrNegativeSqrt float64</pre>
	<p>
	ve ona bir
	<pre>func (e ErrNegativeSqrt) Error() string</pre>
	<p>
	 metodu ekleyerek <code>error</code> haline getirin
	<code>ErrNegativeSqrt(-2).Error()</code>'un
	<code>"Negatif sayıların karekökü alınamaz: -2"</code> döndürmesi gibi.
	<p>
	<b>Not:</b> <code>Error</code> metodunun içindeki "<code>fmt.Print(e)</code>"e yapılan bir çağrı
	programı sonsuz bir döngünün içerisine sokacaktır.
	Öncelikle <code>e</code>'yi değiştirerek bunu önleyebilirsiniz:
	<code>fmt.Print(float64(e))</code>. Neden?
	<p>
	<code>Sqrt</code> fonksiyonunuzu negatif sayı verildiğinde
	<code>ErrNegativeSqrt</code> döndürecek biçimde değiştirin.
<pre class="source">package main

import (
	"fmt"
)

func Sqrt(f float64) (float64, error) {
	return 0, nil
}

func main() {
	fmt.Println(Sqrt(2))
	fmt.Println(Sqrt(-2))
}</pre>
</div>

<div class="slide localMode">
	<h2>Uygulama: HTTP İşleyicileri</h2>
	<p>
	ServeHTTP metodlarını tanımlamak için aşağıdaki türleri kullanın.
	Web sunucunuzdaki spesifik yolları kontrol edebilmek için kaydedin.
<pre>type String string

type Struct struct {
	Greeting string
	Punct    string
	Who      string
}</pre>
	<p>
	Örneğin, işleyici kayıtlarını kaydedebilir olmalısınız:
<pre>http.Handle("/string", String("Ben yıpranmış bir düğümüm."))
http.Handle("/struct", &amp;Struct{"Merhaba", ":", "Gophers!"})</pre>
<pre class="source">package main

import (
	"net/http"
)

func main() {
	// http.handle'ınız burayı çağırır
	http.ListenAndServe("localhost:4000", nil)
}</pre>
</div>

<div class="slide">
	<h2>Uygulama: Görüntüler</h2>
	<p>
	Daha önceden yazdığınız görüntü vericiyi hatırladınız mı?
	Hadi bir tane daha yazalım ama bu defa bir dilim veri döndürmek yerine
	<code>image.Image</code> döndürsün.
	<p>
	Kendi <code>Image</code> türünüzü tanımlayın, 
	<a href="http://golang.org/pkg/image/#Image" target="_blank">gerekli metodları</a>,
	tamamlayın ve "<code>pic.ShowImage</code>"i çağırın.
	<p>
	<code>Bounds</code>, <code>image.Rect(0, 0, w, h)</code> gibi bir
	<code>image.Rectangle</code> döndürmeli.
	<p>
	<code>ColorModel</code>, <code>color.RGBAModel</code> döndürmeli.
	<p>
	<code>At</code> bir renk döndürmeli;
	son görüntü vericideki <code>v</code> değeri bu defa
	<code>color.RGBA{v, v, 255, 255}</code>'e tekabül etmeli.

<pre class="source">package main

import (
	"image"
	"<span class="appengineMode">tour</span><span class="localMode">code.google.com/p/go-tour</span>/pic"
)

type Image struct{}

func main() {
	m := Image{}
	pic.ShowImage(m)
}</pre>
</div>

<div class="slide">
	<h2>Uygulama: Rot13 Okuyucu</h2>
	<p>
	Bilindik modellerden biri
	<a target="_blank" href="http://golang.org/pkg/io/#Reader">io.Reader</a>'dır, 
	başka bir <code>io.Reader</code>'ı sarar, bir şekilde akımı düzenler.
	<p>
	Örneğin, 
	<a target="_blank" href="http://golang.org/pkg/compress/gzip/#NewReader">gzip.NewReader</a>
	fonksiyonu bir <code>io.Reader</code> alır ("gzipped" verinin bir parçası)
	ve onu bir <code>*gzip.Reader</code>'a çevirir ayrıca
	<code>io.Reader</code>'ı da gerçekler (sıkıştırılmış verinin bir parçası).
	<p>
	<a target="_blank" href="http://en.wikipedia.org/wiki/ROT13">ROT13</a> kullanarak alfabedeki tüm harfleri şifreleyen 
	<code>io.Reader</code>'dan okuyup yine <code>io.Reader</code>'a yazan bir <code>rot13Reader</code>'ı, 
	veri akışını düzenleyerek uygulayın.
	<p>
	<code>rot13Reader</code> türü sizin için tahsis edildi.  <code>Read</code> metodunu
	kullanarak onu bir <code>io.Reader</code> yapın.
<pre class="source">package main

import (
	"io"
	"os"
	"strings"
)

type rot13Reader struct {
	r io.Reader
}

func main() {
	s := strings.NewReader(
		"Lbh penpxrq gur pbqr!")
	r := rot13Reader{s}
	io.Copy(os.Stdout, &amp;r)
}</pre>
</div>

<div class="toc">Eşzamanlılık</div>

<div class="slide nocode">
<h2>Eşzamanlılık</h2>
</div>

<div class="slide">
	<h2>Gorutinleri</h2>
	<p>
	"<i>gorutini</i>" Go tarafından yönetilen hafif bir iş parçacığıdır.
	<pre>go f(x, y, z)</pre>
	<p>
	yeni bir gorutini başlatır
	<pre>f(x, y, z)</pre>
	<p>
	'<code>f</code>', '<code>x</code>', '<code>y</code>', ve '<code>z</code>'nin
	değerlendirilmesi aynı gorutinde <code>f</code>'nin içinde, <code>f</code>'nin
	değerlendirilmesi ise yeni bir gorutininde gerçekleşir.
	<p>
	Gorutinleri aynı adres boşluğunda çalışır, bu yüzden paylaşılmış bellek erişimi
	mutlaka senkronize edilmelidir. <code><a href="http://golang.org/pkg/sync/"
	target="_blank">sync</a></code> paketi yararlı "ilkellikler" sağlar,
	yine de Go'da başka "ilkel paketler" olduğundan buna çok ihtiyaç duymayacaksınız.
	(Bir sonraki slayta geçin.)
<pre class="source">package main

import (
	"fmt"
	"<span class="appengineMode">runtime</span><span class="localMode">time</span>"
)

func say(s string) {
	for i := 0; i &lt; 5; i++ {
		<span class="appengineMode">runtime.Gosched()</span><span class="localMode">time.Sleep(100 * time.Millisecond)</span>
		fmt.Println(s)
	}
}

func main() {
	go say("dünya")
	say("merhaba")
}</pre>
</div>

<div class="slide">
	<h2>Kanallar</h2>

	<p>
	Kanallar, kanal operatörü vasıtasıyla değer gönderip alabildiğiniz veri akışı sağlayan bir türdür, 
<code>&lt;-</code>.
<pre>ch &lt;- v    // v'yi ch kanalına yolla.
v := &lt;-ch  // ch'den al ve
           // değeri v'ye ata.</pre>
	<p>
	(Veri akışı ok yönünde gerçekleşir.)

	<p>
	Tıpkı eşlemler ve dilimler gibi kanallar da:
<pre>ch := make(chan int)</pre>
	kullanılmadan önce oluşturulmalıdır.
	<p>
	Varsayılan olarak, diğer taraf da hazır olduğunda blok gönderme/alma işlemleri yapılır.
	Bu da gorutinlerini açık kilitlenmelerden ya da koşullu değişkenlerin senkronize
	edilememesinden korur.
<pre class="source">package main

import "fmt"

func sum(a []int, c chan int) {
	sum := 0
	for _, v := range a {
		sum += v
	}
	c &lt;- sum  // sum'ı c'ye yolla
}

func main() {
	a := []int{7, 2, 8, -9, 4, 0}

	c := make(chan int)
	go sum(a[:len(a)/2], c)
	go sum(a[len(a)/2:], c)
	x, y := &lt;-c, &lt;-c  // c'den al

	fmt.Println(x, y, x + y)
}</pre>
</div>


<div class="slide">
	<h2>Tamponlu Kanallar</h2>

	<p>
	Kanallar <i>tamponlanabilir</i>.  Tamponlanmış bir kanalı tanımlamak için
	ikinci argümanı <code>make</code> edip, tampon uzunluğunu temin edin:
<pre>ch := make(chan int, 100)</pre>

	<p>
	Kodu, bloğu yalnızca tampon dolu olduğunda tamponlanmış kanala gönderir.
	Tampon boş olduğunda ise bloğu temin eder.

	<p>
	Örneği tamponu gereğinden fazla olacak şekilde düzenleyip, ne olduğunu gözlemleyin.

<pre class="source">package main

import "fmt"

func main() {
	c := make(chan int, 2)
	c &lt;- 1
	c &lt;- 2
	fmt.Println(&lt;-c)
	fmt.Println(&lt;-c)
}</pre>
</div>

<div class="slide">
	<h2>Range and Close</h2>
	<p>
	Gönderici bir kanalı daha fazla değer alınmaması gerektiğinde 
	<code>close</code> edebilir (kapatabilir). Alıcılar, alıcı ifadeye ikinci bir parametre ataması yaparak
	kanalın kapalı olup olmadığını öğrenebilir:
	<pre>v, ok := &lt;-ch</pre>
	<p>
	Eğer alınacak başka değer kalmamış ve kanal kapatılmışsa <code>ok</code>, <code>false</code> olacaktır.
	<p>
	<code>for i := range c</code> döngüsü değerleri kanaldan tekrar tekrar alır
	ta ki kanal kapanana kadar.
	<p>
	<b>Not:</b> Yalnızca gönderen kanalı kapatmalıdır, alıcı asla kapatmamalıdır.
	Kapalı kanala bir şeyler göndermek paniğe yol açabilir.
	<p>
	<b>Bir başka not</b>: Kanallar dosya gibi değildir; genellikle kapatma ihtiyacı
	duyulmaz. Kapatma işlemi yalnızca alıcıya daha başka değer gelmeyeceğini bildirmek
	maksadıyla yapılır, tıpkı bir "<code>range</code>" döngüsünü sonlandırmak gibi.
<pre class="source">package main

import (
	"fmt"
)

func fibonacci(n int, c chan int) {
	x, y := 0, 1
	for i := 0; i &lt; n; i++ {
		c &lt;- x
		x, y = y, x + y
	}
	close(c)
}

func main() {
	c := make(chan int, 10)
	go fibonacci(cap(c), c)
	for i := range c {
		fmt.Println(i)
	}
}</pre>
</div>

<div class="slide">
	<h2>Seçmek</h2>
	<p>
	"<code>select</code>" ifadesi gorutinin birden fazla iletişim işleminde beklemesine 
	izin verir.
	<p>
	Bir <code>select</code> "case"lerinden biri çalıştırılabilene kadar tıkalıdır, uygun duruma geldiğinde
	"case"i çalıştırır.  Eğer birden fazla çalıştırılabilir "case" varsa rastgele seçer.
<pre class="source">package main

import "fmt"

func fibonacci(c, quit chan int) {
	x, y := 0, 1
	for {
		select {
		case c &lt;- x:
			x, y = y, x + y
		case &lt;-quit:
			fmt.Println("quit")
			return
		}
	}
}

func main() {
	c := make(chan int)
	quit := make(chan int)
	go func() {
		for i := 0; i &lt; 10; i++ {
			fmt.Println(&lt;-c)
		}
		quit &lt;- 0
	}()
	fibonacci(c, quit)
}</pre>
</div>

<div class="slide">
	<h2>Varsayılan Seçim</h2>
	<p>
	"<code>default</code> case"i, "<code>select</code>"in içerisindedir
	eğer hazırda başka case yoksa çalıştırılır.
	<p>
	"<code>default</code> case"i bloklama yapmadan alma ya da gönderme yapmak için
	deneyin:
	<pre>select {
case i := &lt;-c:
	// i'yi kulllan
default:
	// c'den almak bloklamalıydı
}</pre>
	<p>
	<span class="appengineMode">
	<b>Not:</b> Bu örnek web-tabanlı kullanıcı arayüzünde çalışmaz çünkü 
	"sandbox" envanterinde zamanın bir konsepti yoktur. Bunun için
	<a target="_blank" href="http://golang.org/doc/install/">Go yüklemek</a>
	isteyebilirsiniz.
	</span>
<pre class="source">package main

import (
	"fmt"
	"time"
)

func main() {
	tick := time.Tick(1e8)
	boom := time.After(5e8)
	for {
		select {
		case &lt;-tick:
			fmt.Println("tick.")
		case &lt;-boom:
			fmt.Println("BOOM!")
			return
		default:
			fmt.Println("    .")
			time.Sleep(5e7)
		}
	}
	}</pre>
</div>

<div class="slide nocode">
	<h2>Uygulama: Eşdeğer Binary Ağaçları</h2>
	<p>
	Değerleri aynı sırada depolanmış birden fazla binary apacı olabilir.
	Örneğin, burada iki binary ağacı var
	1, 1, 2, 3, 5, 8, 13.
	<img src="static/fig4.png" alt="binary trees">
	<p>
	Aynı sırada iki binary apacı olup olmadığını kontrol eden fonksiyon bir çok dilde 
	bir hayli karışıktır. Daha basit bir çözüm sunabilmek adına Go'nun
	eşzamanlılığını ve kanallarını kullanacağız.
	<p>
	Bu örnek <code>tree</code> paketini kullanır, bu paket:
<pre>type Tree struct {
	Left  *Tree
	Value int
	Right *Tree
}</pre>
</div>
	türlerini tanımlar.

<div class="slide">
	<h2>Uygulama: Eşdeğer Binary Ağaçları</h2>
	<p>
	<b>1.</b> <code>Walk</code> fonksiyonunu çağırın.
	<p>
	<b>2.</b> <code>Walk</code> fonksiyonunu test edin.
	<p>
	"<code>tree.New(k)</code>" fonksiyonu <code>k</code>, <code>2k</code>, <code>3k</code>, ...,
	<code>10k</code> değerlerini tutarak rastgele-yapılandırılmış bir binary ağacı
	inşa eder.
	<p>
	<code>ch</code> adında bir kanal oluşturun ve walker'ı dışarı atın:
	<pre>go Walk(tree.New(1), ch)</pre>
	<p>
	Daha sonra kanaldan 10 değeri okuyun ve yazın.
	Değerler 1, 2, 3, ..., 10 olmalı.
	<p>
	<b>3.</b> <code>t1</code> ve <code>t2</code>'nin aynı değeri saklamasına karşın
	<code>Same</code> fonksiyonunu <code>Walk</code> kullanarak uygulayın.
	<p>
	<b>4.</b> <code>Same</code> fonksiyonunu test edin.
	<p>
	<code>Same(tree.New(1), tree.New(1))</code> true döndürmeli ve
	<code>Same(tree.New(1), tree.New(2))</code> false döndürmeli.

<pre class="source">package main

import "<span class="appengineMode">tour</span><span class="localMode">code.google.com/p/go-tour</span>/tree"

// Walk t ağacındaki verileri ch kanalına
// göndermek için ağaca doğru yürüyor.
func Walk(t *tree.Tree, ch chan int)

// Same, t1 ve t2'nin aynı değeri depolayıp
// depolamadığını belirtiyor.
func Same(t1, t2 *tree.Tree) bool

func main() {
}</pre>
</div>

<div class="slide">
	<h2>Uygulama: Web Crawler</h2>
	<p>
	Bu uygulamada Go'nun eşzamanlılık özelliğini web crawler ile paralelleştirmeyi
	öğreneceksiniz.
	<p>
	<code>Crawl</code> fonksiyonunu paraleldeki URL'leri çekecek biçimde
	düzenleyin, aynı URL'yi iki defa çekmemesine dikkat edin.
<pre class="source">package main

import (
	"fmt"
)

type Fetcher interface {
	// Fetch URL'nin gövdesini döndürüyor ve
	// URL'nin bir parçası o sayfada bulunuyor.
	Fetch(url string) (body string, urls []string, err error)
}

// Crawl, maksimum derinlik için url ile başlayan 
// yinelenen "crawl" sayfalarında fetcher'u kullanıyor.
func Crawl(url string, depth int, fetcher Fetcher) {
	// TODO: URL'leri paralelden çek.
	// TODO: Aynı URL'yi iki defa çekme.
	// Bu uygulama şunu yapmaz:
	if depth &lt;= 0 {
		return
	}
	body, urls, err := fetcher.Fetch(url)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("found: %s %q\n", url, body)
	for _, u := range urls {
		Crawl(u, depth-1, fetcher)
	}
	return
}

func main() {
	Crawl("http://golang.org/", 4, fetcher)
}


// fakeFetcher, kaydedilmiş sonuçları döndüren Fetcher'dır.
type fakeFetcher map[string]*fakeResult

type fakeResult struct {
	body string
	urls     []string
}

func (f *fakeFetcher) Fetch(url string) (string, []string, error) {
	if res, ok := (*f)[url]; ok {
		return res.body, res.urls, nil
	}
	return "", nil, fmt.Errorf("bulunamadı: %s", url)
}

// fetcher daha dolu bir fakeFetcher'dır.
var fetcher = &amp;fakeFetcher{
	"http://golang.org/": &amp;fakeResult{
		"Go programlama dili",
		[]string{
			"http://golang.org/pkg/",
			"http://golang.org/cmd/",
		},
	},
	"http://golang.org/pkg/": &amp;fakeResult{
		"Paketler",
		[]string{
			"http://golang.org/",
			"http://golang.org/cmd/",
			"http://golang.org/pkg/fmt/",
			"http://golang.org/pkg/os/",
		},
	},
	"http://golang.org/pkg/fmt/": &amp;fakeResult{
		"'fmt' Paketi",
		[]string{
			"http://golang.org/",
			"http://golang.org/pkg/",
		},
	},
	"http://golang.org/pkg/os/": &amp;fakeResult{
		"'os' Paketi",
		[]string{
			"http://golang.org/",
			"http://golang.org/pkg/",
		},
	},
}</pre>
</div>

<div class="slide nocode">
	<h2>Buradan nereye gidiyoruz...</h2>
	<p class="appengineMode">
	<a href="http://golang.org/doc/install/">Go yükleyerek</a> ya da 
	<a href="http://code.google.com/appengine/downloads.html#Google_App_Engine_SDK_for_Go">Go App Engine SDK</a> indirerek başlayabilirsiniz.
	</p>
	<p>
	<span class="appengineMode">Bir defa Go'yu yüklediğinizde,</span>
	<span class="localMode"> </span>
	<a target="_blank" href="http://golang.org/doc/">Go Dokümantasyonu</a> 
	<span class="localMode">başlangıca</span>
	<span class="appengineMode">devam etmek için</span> çok güzel bir yer.
	Kaynakları, eğitimi, videoları, ve fazlasını içinde bulunduruyor.
	<p>
	Standart kütüphane ile ilgili yardıma ihtiyacınız olursa,
	<a target="_blank" href="http://golang.org/pkg/">kaynak pakete</a> bir göz atın.
	Dilin kendisine yardım etmek için, 
	<a target="_blank" href="http://golang.org/ref/spec">Dil Belirtimi</a>'ni, epey okunabilir bulduğunuzda şaşırabilirsiniz.
	<p>
	Go'nun eşzamanlı modeli hakkında daha fazla araştırma için, 
	<a target="_blank" href="http://golang.org/doc/codewalk/sharemem/">İletişimde Paylaşılan Hafıza</a>'ya göz atın.
	<p>
	<a target="_blank" href="http://golang.org/doc/codewalk/functions/">Go'da Birinci Sınıf Fonksiyonlar</a>
	Go'nun fonksiyon türleri hakkında ilginç bir bakış açısı sunacak.
	<p>
	<a target="_blank" href="http://blog.golang.org/">Go Blog</a> Go makaleleriyle alakalı
	büyük bir arşive sahip.
	<p>
	Daha fazlası için <a target="_blank" href="http://golang.org">golang.org</a>'u ziyaret edin.
</div>

</div><!-- end slides -->

<div id="workspace">
	<div class="controls">
		<div><a id="Run" href="#run" title="Derle ve Çalıştır">Çalıştır</a><a href="#more" id="more" title="Seçenekler">▼</a></div>
		<ul class="more">
			<li><a href="#" id="reset">Slaytı Tekrarla</a></li>
			<li><a href="#" id="format">Kaynak Kodu Biçimlendir</a></li>
			<li><a href="#" id="kill" class="localMode">Programı Bitir</a></li>
			<li><hr></li>
			<li><a href="#" id="togglesyntax">Syntax-Aydınlatması: kapat</a></li>
			<li><a href="#" id="togglelineno">Satır Numaraları: aç</a></li>
		</ul>
	</div>

	<div id="workspace-top">
		<div id="workspace-editor">
			<textarea id="editor" spellcheck="false"></textarea>
		</div>
	</div>

	<div id="workspace-bottom">
		<div id="output"></div>
	</div>
</div>
</div>

</body>
</html>
